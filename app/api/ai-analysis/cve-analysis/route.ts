import { NextRequest, NextResponse } from 'next/server'

const GROQ_URL = 'https://api.groq.com/openai/v1/chat/completions'
const DEFAULT_MODEL = process.env.GROQ_MODEL || 'llama-3.3-70b-versatile'

interface GroqResponse {
  choices: Array<{
    message: {
      content: string
    }
  }>
}

async function groqChat(
  apiKey: string,
  userContent: string,
  model: string = DEFAULT_MODEL,
  maxTokens: number = 2048,
  temperature: number = 0.3
): Promise<string> {
  const headers = {
    'Authorization': `Bearer ${apiKey}`,
    'Content-Type': 'application/json',
  }

  const payload = {
    model,
    messages: [{ role: 'user', content: userContent }],
    max_completion_tokens: Math.min(maxTokens, 8192),
    temperature,
  }

  const response = await fetch(GROQ_URL, {
    method: 'POST',
    headers,
    body: JSON.stringify(payload),
  })

  if (!response.ok) {
    const errorText = await response.text()
    let error: any = errorText
    try {
      error = JSON.parse(errorText)
    } catch {
      // Keep as text
    }
    throw new Error(`Groq API error ${response.status}: ${JSON.stringify(error)}`)
  }

  const data: GroqResponse = await response.json()
  const choice = data.choices?.[0]
  if (!choice) {
    throw new Error('Groq returned no choices')
  }

  return (choice.message?.content || '').trim()
}

function extractCVEFromResponse(text: string): string {
  const cveRegex = /CVE-\d{4}-\d{4,}/i
  const match = text.match(cveRegex)
  return match ? match[0] : text.trim().substring(0, 200)
}

function collectExploitNames(data: any): string[] {
  const names: string[] = []
  const seen = new Set<string>()

  function traverse(obj: any) {
    if (typeof obj !== 'object' || obj === null) return

    if (Array.isArray(obj)) {
      obj.forEach(item => traverse(item))
      return
    }

    // Check for exploit_name field
    if (obj.exploit_name) {
      if (typeof obj.exploit_name === 'string' && obj.exploit_name.trim()) {
        const name = obj.exploit_name.trim()
        if (!seen.has(name)) {
          seen.add(name)
          names.push(name)
        }
      } else if (Array.isArray(obj.exploit_name)) {
        obj.exploit_name.forEach((name: any) => {
          if (typeof name === 'string' && name.trim()) {
            const trimmed = name.trim()
            if (!seen.has(trimmed)) {
              seen.add(trimmed)
              names.push(trimmed)
            }
          } else if (typeof name === 'object' && name?.exploit_name) {
            const trimmed = String(name.exploit_name).trim()
            if (!seen.has(trimmed)) {
              seen.add(trimmed)
              names.push(trimmed)
            }
          }
        })
      }
    }

    // Check for findings/results/exploits arrays
    for (const key of ['findings', 'results', 'exploits', 'items']) {
      if (Array.isArray(obj[key])) {
        obj[key].forEach((item: any) => {
          if (typeof item === 'object' && item?.exploit_name) {
            const trimmed = String(item.exploit_name).trim()
            if (!seen.has(trimmed)) {
              seen.add(trimmed)
              names.push(trimmed)
            }
          }
        })
      }
    }

    // Parse raw_output if it's a string (might be JSON)
    if (obj.raw_output && typeof obj.raw_output === 'string') {
      try {
        const parsed = JSON.parse(obj.raw_output)
        traverse(parsed)
      } catch {
        // If not JSON, try to extract exploit names from text
        const exploitPatterns = [
          /(?:exploit|vulnerability|CVE|module)[\s:]+([A-Z0-9\-_\.]+)/gi,
          /CVE-\d{4}-\d{4,}/gi,
          /(?:T\d+\.\d+)[\s:]+([A-Z0-9\-_]+)/gi,
        ]
        
        exploitPatterns.forEach(pattern => {
          const matches = obj.raw_output.matchAll(pattern)
          for (const match of matches) {
            const name = match[1] || match[0]
            if (name && name.trim() && !seen.has(name.trim())) {
              seen.add(name.trim())
              names.push(name.trim())
            }
          }
        })
      }
    }

    // Extract from attack_timeline commands/actions if available
    if (obj.attack_timeline && Array.isArray(obj.attack_timeline)) {
      obj.attack_timeline.forEach((event: any) => {
        if (event.command) {
          const commandMatch = event.command.match(/(?:exploit|poc|payload|vuln|module)[\s\/:]+([^\s]+)/i)
          if (commandMatch && commandMatch[1] && !seen.has(commandMatch[1])) {
            seen.add(commandMatch[1])
            names.push(commandMatch[1])
          }
        }
        if (event.action) {
          const actionMatch = event.action.match(/(?:T\d+\.\d+|exploit|module)[\s:]+([^\s,]+)/i)
          if (actionMatch && actionMatch[1] && !seen.has(actionMatch[1])) {
            seen.add(actionMatch[1])
            names.push(actionMatch[1])
          }
        }
      })
    }

    // Extract from attack_summary overview
    if (obj.attack_summary?.overview) {
      const overviewMatch = obj.attack_summary.overview.match(/(?:CVE|exploit|vulnerability)[\s:]+([A-Z0-9\-_]+)/i)
      if (overviewMatch && overviewMatch[1] && !seen.has(overviewMatch[1])) {
        seen.add(overviewMatch[1])
        names.push(overviewMatch[1])
      }
    }

    // Extract from kill chain weaponization attacks
    if (obj.killChain?.weaponization?.selectedAttacks) {
      obj.killChain.weaponization.selectedAttacks.forEach((attack: any) => {
        if (attack.module_path && !seen.has(attack.module_path)) {
          seen.add(attack.module_path)
          names.push(attack.module_path)
        }
        if (attack.name && !seen.has(attack.name)) {
          seen.add(attack.name)
          names.push(attack.name)
        }
      })
    }

    // Extract from attack vectors
    if (obj.attackVectors && Array.isArray(obj.attackVectors)) {
      obj.attackVectors.forEach((vector: any) => {
        if (vector.killChain?.weaponization?.selectedAttacks) {
          vector.killChain.weaponization.selectedAttacks.forEach((attack: any) => {
            if (attack.module_path && !seen.has(attack.module_path)) {
              seen.add(attack.module_path)
              names.push(attack.module_path)
            }
            if (attack.name && !seen.has(attack.name)) {
              seen.add(attack.name)
              names.push(attack.name)
            }
          })
        }
        // Extract from execution results
        if (vector.executionResults) {
          Object.values(vector.executionResults).forEach((result: any) => {
            if (result?.output) {
              const outputStr = typeof result.output === 'string' ? result.output : JSON.stringify(result.output)
              const moduleMatch = outputStr.match(/(?:exploit|module|use)\s+([\/\w\-]+)/gi)
              if (moduleMatch) {
                moduleMatch.forEach(match => {
                  const module = match.replace(/(?:exploit|module|use)\s+/i, '').trim()
                  if (module && !seen.has(module)) {
                    seen.add(module)
                    names.push(module)
                  }
                })
              }
            }
          })
        }
      })
    }

    // Extract from module_path field (common in attack modules)
    if (obj.module_path && typeof obj.module_path === 'string' && !seen.has(obj.module_path)) {
      seen.add(obj.module_path)
      names.push(obj.module_path)
    }

    // Extract from attack_type and module combinations
    if (obj.attack_type && obj.module) {
      const combined = `${obj.attack_type}_${obj.module}`
      if (!seen.has(combined)) {
        seen.add(combined)
        names.push(combined)
      }
    }

    // Recursively traverse all values
    Object.values(obj).forEach(value => traverse(value))
  }

  traverse(data)
  return names
}

async function mapExploitToCVE(apiKey: string, exploitName: string, model: string, customPrompt?: string): Promise<string> {
  const prompt = customPrompt
    ? customPrompt.replace(/{exploit_name}/g, exploitName)
    : `Map this security exploit or vulnerability name to its official CVE identifier(s).
Exploit name: "${exploitName}".
Reply with only the CVE ID(s), one per line if multiple (e.g. CVE-2024-1234).
If no CVE exists, reply with "N/A". Do not add explanation.`
  
  const reply = await groqChat(apiKey, prompt, model, 256)
  return extractCVEFromResponse(reply)
}

async function getRemediationSteps(apiKey: string, cveId: string, model: string, customPrompt?: string): Promise<string> {
  const prompt = customPrompt
    ? customPrompt.replace(/{cve_id}/g, cveId)
    : `Provide clear, actionable remediation steps for ${cveId}.
Use a numbered list. Include patching, configuration changes, and mitigation.
Keep the response concise but complete.`
  
  return await groqChat(apiKey, prompt, model, 1024)
}

async function getSigmaAndQueries(apiKey: string, cveId: string, model: string, customPrompt?: string): Promise<string> {
  const prompt = customPrompt
    ? customPrompt.replace(/{cve_id}/g, cveId)
    : `For ${cveId}: (1) Write one or more SIGMA detection rules (YAML) that could detect exploitation.
(2) Then convert those SIGMA rules into concrete detection queries (e.g. KQL for Microsoft Defender, Splunk SPL, or generic SIEM query).
Output both the SIGMA rule(s) and the corresponding runnable queries clearly labeled.`
  
  return await groqChat(apiKey, prompt, model, 2048)
}

async function getEndpointMitigationCommands(apiKey: string, cveId: string, model: string, customPrompt?: string): Promise<string> {
  const prompt = customPrompt 
    ? customPrompt.replace(/{cve_id}/g, cveId)
    : `For ${cveId}, provide Endpoint mitigation commands that can be deployed on a compromised endpoint.
Include: Windows (PowerShell or CMD), and Linux (bash) where relevant.
Commands should be runnable (e.g. disable a service, apply a registry fix, block a path).
List each command with a short description. Do not use placeholders like <path> without example.`
  
  return await groqChat(apiKey, prompt, model, 2048)
}

async function getWhatActuallyHappened(apiKey: string, exploitName: string, attackResults: any, model: string, customPrompt?: string): Promise<string> {
  // Format attack results for the prompt
  const attackResultsText = JSON.stringify(attackResults, null, 2)
  
  const prompt = customPrompt
    ? customPrompt.replace(/{attack_results}/g, attackResultsText).replace(/{exploit_name}/g, exploitName)
    : `Based on the following pentest attack results, provide a clear and detailed summary of what actually happened during the attack.
Include: attack type, target information, exploitation method, successful actions, and any evidence of compromise.

Exploit/Vulnerability: ${exploitName}

Attack Results:
${attackResultsText}

Provide a comprehensive summary of the actual attack execution and its outcomes.`
  
  return await groqChat(apiKey, prompt, model, 2048)
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { exploit_data, execution_id, ai_prompt_settings } = body

    // Get API key from environment
    const apiKey = process.env.GROQ_API_KEY
    if (!apiKey) {
      return NextResponse.json(
        { success: false, error: 'GROQ_API_KEY environment variable not set' },
        { status: 500 }
      )
    }

    const model = process.env.GROQ_MODEL || DEFAULT_MODEL

    // Collect exploit names from the data
    const exploitNames = collectExploitNames(exploit_data)
    
    if (exploitNames.length === 0) {
      return NextResponse.json(
        { success: false, error: 'No exploit names found in the provided data' },
        { status: 400 }
      )
    }

    // Extract attack results for "what actually happened" analysis
    const attackResults = exploit_data.attack_results || []
    const currentAttack = exploit_data.current_attack || null
    const allAttackResults = currentAttack ? [...attackResults, currentAttack] : attackResults

    const results = []

    // Process each exploit
    for (let i = 0; i < exploitNames.length; i++) {
      const exploitName = exploitNames[i]
      
      console.log(`[CVE ANALYSIS] Processing (${i + 1}/${exploitNames.length}): ${exploitName}`)

      // Get what actually happened from pentest results
      const whatActuallyHappened = await getWhatActuallyHappened(
        apiKey, 
        exploitName, 
        allAttackResults.length > 0 ? allAttackResults : exploit_data,
        model,
        ai_prompt_settings?.getWhatActuallyHappened
      )
      await new Promise(resolve => setTimeout(resolve, 500))

      // Map exploit to CVE
      const cveId = await mapExploitToCVE(apiKey, exploitName, model, ai_prompt_settings?.mapExploitToCVE)
      await new Promise(resolve => setTimeout(resolve, 500)) // Delay between calls

      // Get remediation steps
      const remediation = await getRemediationSteps(apiKey, cveId, model, ai_prompt_settings?.getRemediationSteps)
      await new Promise(resolve => setTimeout(resolve, 500))

      // Get SIGMA rules and queries
      const sigmaQueries = await getSigmaAndQueries(apiKey, cveId, model, ai_prompt_settings?.getSigmaAndQueries)
      await new Promise(resolve => setTimeout(resolve, 500))

      // Get endpoint mitigation commands
      const mitigation = await getEndpointMitigationCommands(apiKey, cveId, model, ai_prompt_settings?.getEndpointMitigationCommands)
      await new Promise(resolve => setTimeout(resolve, 500))

      results.push({
        exploit_name: exploitName,
        cve_id: cveId,
        what_actually_happened: whatActuallyHappened,
        remediation_steps: remediation,
        sigma_detection_queries: sigmaQueries,
        endpoint_mitigation_commands: mitigation,
      })
    }

    return NextResponse.json({
      success: true,
      execution_id,
      results,
      processed_at: new Date().toISOString(),
    })
  } catch (error: any) {
    console.error('[CVE ANALYSIS ERROR]', error)
    return NextResponse.json(
      { success: false, error: error.message || 'Failed to process CVE analysis' },
      { status: 500 }
    )
  }
}

export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  })
}

